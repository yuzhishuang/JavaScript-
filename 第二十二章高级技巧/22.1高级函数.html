<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
//  22.1.1安全的类型检测
//  在任何值上调用Object原生的toString()方法，都会返回一个[欧尼揭穿他NativeConstructorName]格式的字符串。
//  每个类在内部都有一个[[Class]]属性，这个属性中就制定了上述字符串中的构造函数名
var value = [1, 3];
console.log(Object.prototype.toString.call(value));

//  由于原生数组的构造函数名与全局作用域无关，因此使用toString()就能保证返回一致的值
function isArray (value) {
	return Object.prototype.toString.call(value) == "[object Array]";
}

//  同样也可以基于这一思路来测试某个值是不是原生函数或正则表达式
function isFunction (value) {
	return Object.prototype.toString.call(value) == "[object Function]";
}

function isRegExp (value) {
	return Object.prototype.toString.call(value) == "[object RegExp]";
}

//  检测原生JSON对象。Object的toString()方法不能检测非原生构造函数的构造函数名，因此，开发人员定义的任何构造函数都将返回[object Object]
// var isNativeJSON = window.JSON && object.prototype.toString.call(JSON) == "[object JSON]";



//  22.1.2作用域安全的构造函数
//  问题出在当没有使用new操作符来调用该构造函数的情况上。由于该this对象是在运行时绑定的，所以直接调用Person(),this会映射到全局对象window上
//  导致错误对象属性的意外增加
function Person (name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
}
var person = Person("yzs", 29, "software");
console.log(window.name, window.age, window.job);

//  由于window的name属性是用于识别链接目标和frame的，所以这里对该属性的偶然覆盖可能会导致该页面上出现其他错误。
//  这个问题的解决方法就是创建一个作用域安全的构造函数

</script>
</body>
</html>